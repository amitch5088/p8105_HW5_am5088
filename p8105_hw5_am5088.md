p8105_hw5_am5088
================
Anika Mitchell am5088

load my necessary libraries

## Problem 1

I‚Äôve gone ahead and loaded my necessary libraries and set up plotting
for this problem (tidyverse), and will now start to develop a function
to address the following question:

Suppose you put ùëõpeople in a room, and want to know the probability that
at least two people share a birthday. For simplicity, we‚Äôll assume there
are no leap years (i.e.¬†there are only 365 days) and that birthdays are
uniformly distributed over the year (which is actually not the case).

**Write a function that, for a fixed group size, randomly draws
‚Äúbirthdays‚Äù for each person; checks whether there are duplicate
birthdays in the group; and returns TRUE or FALSE based on the result.**

``` r
shared_birthdays = function(n) {
  
  random_birthdays = sample(1:365, size = n, replace = TRUE)
  return(any(duplicated(random_birthdays)))
}
```

Now I‚Äôm going to test this function:

``` r
shared_birthdays(40)
```

    ## [1] TRUE

``` r
shared_birthdays(12)
```

    ## [1] FALSE

Okay, after testing this function, a couple of times it appears that it
is working okay. That is, it is able to produce either TRUE or FALSE
based on the sample size of n people and if there are any duplicated
birthdays in the mix. When I test the function with 40, I get TRUE, and
with 12 people I get FALSE.

**Next, run this function 10000 times for each group size between 2 and
50. For each group size, compute the probability that at least two
people in the group will share a birthday by averaging across the 10000
simulation runs. Make a plot showing the probability as a function of
group size, and comment on your results.**

loop function

``` r
results_df = tibble(
  group_size = integer(),
  prob_shared_birthdays = numeric()
)
set.seed
```

    ## function (seed, kind = NULL, normal.kind = NULL, sample.kind = NULL) 
    ## {
    ##     kinds <- c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", 
    ##         "Mersenne-Twister", "Knuth-TAOCP", "user-supplied", "Knuth-TAOCP-2002", 
    ##         "L'Ecuyer-CMRG", "default")
    ##     n.kinds <- c("Buggy Kinderman-Ramage", "Ahrens-Dieter", "Box-Muller", 
    ##         "user-supplied", "Inversion", "Kinderman-Ramage", "default")
    ##     s.kinds <- c("Rounding", "Rejection", "default")
    ##     if (length(kind)) {
    ##         if (!is.character(kind) || length(kind) > 1L) 
    ##             stop("'kind' must be a character string of length 1 (RNG to be used).")
    ##         if (is.na(i.knd <- pmatch(kind, kinds) - 1L)) 
    ##             stop(gettextf("'%s' is not a valid abbreviation of an RNG", 
    ##                 kind), domain = NA)
    ##         if (i.knd == length(kinds) - 1L) 
    ##             i.knd <- -1L
    ##     }
    ##     else i.knd <- NULL
    ##     if (!is.null(normal.kind)) {
    ##         if (!is.character(normal.kind) || length(normal.kind) != 
    ##             1L) 
    ##             stop("'normal.kind' must be a character string of length 1")
    ##         normal.kind <- pmatch(normal.kind, n.kinds) - 1L
    ##         if (is.na(normal.kind)) 
    ##             stop(gettextf("'%s' is not a valid choice", normal.kind), 
    ##                 domain = NA)
    ##         if (normal.kind == 0L) 
    ##             stop("buggy version of Kinderman-Ramage generator is not allowed", 
    ##                 domain = NA)
    ##         if (normal.kind == length(n.kinds) - 1L) 
    ##             normal.kind <- -1L
    ##     }
    ##     if (!is.null(sample.kind)) {
    ##         if (!is.character(sample.kind) || length(sample.kind) != 
    ##             1L) 
    ##             stop("'sample.kind' must be a character string of length 1")
    ##         sample.kind <- pmatch(sample.kind, s.kinds) - 1L
    ##         if (is.na(sample.kind)) 
    ##             stop(gettextf("'%s' is not a valid choice", sample.kind), 
    ##                 domain = NA)
    ##         if (sample.kind == 0L) 
    ##             warning("non-uniform 'Rounding' sampler used", domain = NA)
    ##         if (sample.kind == length(s.kinds) - 1L) 
    ##             sample.kind <- -1L
    ##     }
    ##     .Internal(set.seed(seed, i.knd, normal.kind, sample.kind))
    ## }
    ## <bytecode: 0x1179b8ef0>
    ## <environment: namespace:base>

``` r
for (i in 2:50) {
   shared_birthdays_loop = replicate(10000, shared_birthdays(i))
   results_df = results_df %>%
    add_row(
      group_size = i,
      prob_shared_birthdays = mean(shared_birthdays_loop)
    )
}
```

check out my table

``` r
print(results_df)
```

    ## # A tibble: 49 √ó 2
    ##    group_size prob_shared_birthdays
    ##         <int>                 <dbl>
    ##  1          2                0.0031
    ##  2          3                0.0073
    ##  3          4                0.0177
    ##  4          5                0.0282
    ##  5          6                0.0425
    ##  6          7                0.0592
    ##  7          8                0.0774
    ##  8          9                0.0952
    ##  9         10                0.118 
    ## 10         11                0.136 
    ## # ‚Ñπ 39 more rows

Plot my results table

``` r
ggplot(results_df, aes(x = group_size, y = prob_shared_birthdays)) +
geom_line() +
labs(
  title = "Probability of Shared Birthday as a Function of Group Size",
  x = "Group Size",
  y = "Probability of Shared Birthday"
  )
```

<img src="p8105_hw5_am5088_files/figure-gfm/plot results table-1.png" width="90%" />

This plot confirms what I learned when I tested the function earlier on
a smaller sample size like 12 which had a FALSE result (indicating a
lower probablity of duplication) vs a larger sample size like 40 which
had a TRUE result (indicating a higher probability of duplication) which
is what the plot shows. As the group size increases, the probability of
people having a shared birthday increases which is why live in a world
with a huge sample size (if we could sample the whole world) and a lot
of duplicated birthdays across the 365 days we count in Western society.
On the other hand in my group of close friends which is less than 10,
there are no duplicated birthdays because that probability is lower in a
smaller sample.
